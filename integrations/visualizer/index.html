<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pokémon Card Test Result Visualizer V1.2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* Optional: Add custom styles if needed */
        body {
            background-color: #f1f5f9; /* slate-100 */
            font-family: sans-serif;
        }
        .chart-container {
            position: relative;
            height: 250px;
            width: 100%;
        }
        .summary-stats p { margin-bottom: 0.25rem; }
        .summary-stats .value { font-size: 1.5rem; font-weight: 700; }
        .summary-stats .label { font-size: 0.875rem; font-weight: 500; color: #4b5563; }
        .icon { display: inline-block; width: 1.25em; height: 1.25em; stroke-width: 2; vertical-align: middle; }
        .icon-sm { width: 1em; height: 1em; }
        .test-case-header { cursor: pointer; }
        .card-list { border-left-width: 4px; padding-left: 0.5rem; margin-top: 0.5rem; }
        .card-list h4 { font-weight: 500; color: #374151; }
        .card-list ul { margin-left: 0.5rem; list-style: none; padding-left: 0;}
        .card-list li { font-size: 0.875rem; padding-top: 0.35rem; padding-bottom: 0.35rem; line-height: 1.4;}
        .card-list .card-detail { margin-right: 0.3em; /* Spacing between details */ }
        .card-list .card-id { font-weight: 500; /* Make ID bold */ }
        .card-list .card-name {}
        .card-list .card-set-name { font-style: italic; color: #4b5563; }
        .card-list .card-set-number { font-size: 0.8rem; color: #6b7280; }
        .card-list .card-set-abbr { font-size: 0.8rem; font-weight: 600; color: #6b7280;}
        .card-list .card-price { font-weight: 500; color: #166534; /* Dark green */ }
        .card-list .card-hash { display: block; /* Put hash on new line */ font-size: 0.75rem; color: #a1a1aa; /* Zinc 400 */ word-break: break-all;}

        .badge { font-size: 0.75rem; padding: 0.25rem 0.5rem; border-radius: 9999px; margin-left: 0.5rem; display: inline-block; }
        .failure-reason { background-color: #fee2e2; padding: 0.5rem; border-radius: 0.375rem; margin-top: 0.5rem; color: #b91c1c; font-size: 0.875rem; }
         /* Style for display options */
        #displayOptions label { cursor: pointer; user-select: none; }
        #displayOptions input[type="checkbox"] { vertical-align: middle; }
    </style>
</head>
<body>

    <div class="max-w-6xl mx-auto p-4">
        <h1 class="text-2xl font-bold mb-4">Pokémon Card Test Result Visualizer</h1>

        <div id="displayOptions" class="bg-white p-4 rounded-lg shadow-md mb-6">
            <h3 class="text-lg font-semibold mb-2">Card Display Options:</h3>
            <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-x-4 gap-y-2">
                <div><input type="checkbox" id="toggleName" checked><label for="toggleName" class="ml-1"> Name</label></div>
                <div><input type="checkbox" id="toggleSetName" checked><label for="toggleSetName" class="ml-1"> Set Name</label></div>
                <div><input type="checkbox" id="toggleSetNumber" checked><label for="toggleSetNumber" class="ml-1"> Set Number</label></div>
                <div><input type="checkbox" id="toggleSetAbbr" checked><label for="toggleSetAbbr" class="ml-1"> Set Abbr.</label></div>
                <div><input type="checkbox" id="togglePrice" checked><label for="togglePrice" class="ml-1"> Price</label></div>
                <div><input type="checkbox" id="toggleHash" checked><label for="toggleHash" class="ml-1"> Hash</label></div>
            </div>
        </div>

        <div class="bg-white p-4 rounded-lg shadow-md mb-6">
            <div class="flex items-center mb-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2 text-blue-500 icon"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><line x1="10" y1="9" x2="8" y2="9"></line></svg>
                <h2 class="text-lg font-semibold">Input Log Data</h2>
            </div>
            <textarea id="logInput" class="w-full h-32 p-2 border border-gray-300 rounded-md font-mono text-sm" placeholder="Paste your test log data here..."></textarea>
            <div class="flex justify-between items-center mt-2">
                <p id="errorMessage" class="text-red-500 text-sm"></p>
                <button id="parseButton" class="bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-md ml-auto">Parse Log Data</button>
            </div>
        </div>

        <div id="resultsContainer">
            <div id="summaryChartsContainer" class="flex flex-col md:flex-row items-start justify-center gap-8 mb-8"></div>
            <div id="testCasesContainer" class="bg-white p-4 rounded-lg shadow-md"></div>
        </div>

    </div>

    <script>
        // --- Configuration and State ---
        const COLORS = { /* ... (COLORS remain the same) ... */ };
        let testData = null;
        let expandedTestCase = null;
        let pieChartInstance = null;
        let barChartInstance = null;

        // --- DOM References ---
        const logInput = document.getElementById('logInput');
        const parseButton = document.getElementById('parseButton');
        const errorMessage = document.getElementById('errorMessage');
        const resultsContainer = document.getElementById('resultsContainer');
        const summaryChartsContainer = document.getElementById('summaryChartsContainer');
        const testCasesContainer = document.getElementById('testCasesContainer');
        const displayOptionsContainer = document.getElementById('displayOptions');

        // --- Lucide Icons (Inline SVG) ---
        const ICONS = { /* ... (ICONS remain the same) ... */ };

        // --- Parsing Logic ---

        // Helper to extract value robustly, handling 'null' string
        function extractValue(content, key) {
            // Match key= followed by any characters until the next comma or the end of the string/parenthesis
            const regex = new RegExp(`${key}=([^,)]+)`);
            const match = content.match(regex);
            if (match && match[1]) {
                 const value = match[1].trim();
                 return value === 'null' ? null : value; // Convert 'null' string to actual null
            }
            return null; // Return null if key not found or value is missing
        }

        const parseCards = (cardsStr) => {
            if (!cardsStr || cardsStr === '[]') return [];

            const cardMatches = cardsStr.match(/Card\((.*?)\)/g);
            if (!cardMatches) return [];

            return cardMatches.map(cardMatch => {
                const content = cardMatch.substring(5, cardMatch.length - 1); // Get content inside Card(...)
                const id = extractValue(content, 'id');

                if (!id) return null; // Skip card if no ID is found

                return {
                    id: id,
                    name: extractValue(content, 'name'),
                    setName: extractValue(content, 'setName'),
                    setNumber: extractValue(content, 'setNumber'),
                    setAbbreviation: extractValue(content, 'setAbbreviation'),
                    price: extractValue(content, 'price'),
                    playTextHash: extractValue(content, 'playTextHash')
                };
            }).filter(card => card !== null); // Filter out invalid card structures
        };


        const parseTestResults = (text) => {
             // ... (Initial part of parseTestResults remains the same: splitting lines, mapping basic fields) ...
             const testResultLines = text.split('\n').filter(line => line.includes('Results: TestResult'));

             const testResults = testResultLines.map(line => {
                 const passedMatch = line.match(/passed=(true|false)/);
                 const passed = passedMatch ? passedMatch[1] === 'true' : null;
                 const messageMatch = line.match(/message=\[([^\]]+)\]/);
                 const message = messageMatch ? messageMatch[1] : null;
                 const supposedToFailMatch = line.match(/supposedToFail=(true|false)/);
                 const supposedToFail = supposedToFailMatch ? supposedToFailMatch[1] === 'true' : false;
                 const checkType = message ? (message.includes('Expected Check') ? 'Expected Check' : 'Unexpected Check') : null;

                 // Use regex to find the full Expected: [...] and Unexpected: [...] blocks
                 const expectedBlockMatch = line.match(/Expected: (\[.*?\])/);
                 const expectedCardsStr = expectedBlockMatch ? expectedBlockMatch[1] : '[]';

                 const unexpectedBlockMatch = line.match(/Unexpected: (\[.*?\])/);
                 const unexpectedCardsStr = unexpectedBlockMatch ? unexpectedBlockMatch[1] : '[]';

                 const expectedCards = parseCards(expectedCardsStr);
                 const unexpectedCards = parseCards(unexpectedCardsStr);

                 const categoriesMatch = line.match(/testCategories=\[([^\]]*)\]/);
                 const categoriesStr = categoriesMatch ? categoriesMatch[1] : '';
                 const categories = categoriesStr && categoriesStr !== 'null' && categoriesStr.trim() !== '' ?
                     categoriesStr.split(', ').map(c => c.trim()) : []; // Trim categories

                 return {
                     passed, checkType, message, expectedCards, unexpectedCards, categories, supposedToFail,
                     timestamp: line.split(' ')[0], raw: line
                 };
             });
            // ... (Rest of parseTestResults remains the same: pairing, processing, stats, failures) ...
            const testCases = [];
             for (let i = 0; i < testResults.length; i += 2) {
                 if (i + 1 < testResults.length) {
                     const r1 = testResults[i];
                     const r2 = testResults[i+1];
                      if (r1.checkType && r2.checkType && r1.checkType !== r2.checkType) {
                         const supposedToFail = r1.supposedToFail || r2.supposedToFail;
                          testCases.push({
                             unexpectedCheck: r1.checkType === 'Unexpected Check' ? r1 : r2,
                             expectedCheck: r1.checkType === 'Expected Check' ? r1 : r2,
                             categories: r1.categories.length > 0 ? r1.categories : (r2.categories.length > 0 ? r2.categories : []),
                             passed: r1.passed && r2.passed,
                             supposedToFail: supposedToFail
                          });
                     } else {
                         console.warn("Could not reliably pair test results at index", i);
                     }
                 }
             }

             testCases.forEach((testCase, index) => {
                  testCase.id = index + 1;
                  testCase.expectedCards = testCase.expectedCheck.expectedCards;
                  testCase.unexpectedCards = testCase.unexpectedCheck.unexpectedCards;

                  const cardSeries = new Set();
                  [...testCase.expectedCards, ...testCase.unexpectedCards].forEach(card => {
                     if (card.id) {
                         const series = card.id.split('-')[0];
                         cardSeries.add(series);
                     }
                  });
                  testCase.cardSeries = [...cardSeries];

                 testCase.isDuplicate = testCases.slice(0, index).some(tc =>
                     JSON.stringify(tc.expectedCards) === JSON.stringify(testCase.expectedCards) &&
                     JSON.stringify(tc.unexpectedCards) === JSON.stringify(testCase.unexpectedCards)
                 );
             });

              const uniqueTestCases = testCases.filter(tc => !tc.isDuplicate);
             const passedTests = uniqueTestCases.filter(tc => tc.passed).length;
             const failedTests = uniqueTestCases.length - passedTests;
             const expectedFailedTests = uniqueTestCases.filter(tc => !tc.passed && tc.supposedToFail).length;
             const unexpectedFailedTests = failedTests - expectedFailedTests;
             const allCardSeries = new Set();
             uniqueTestCases.forEach(tc => tc.cardSeries.forEach(series => allCardSeries.add(series)));
             const failureAnalysis = uniqueTestCases
                 .filter(tc => !tc.passed)
                 .map(tc => {
                     let failureReason;
                     if (!tc.unexpectedCheck.passed && tc.expectedCheck.passed) { failureReason = "Unexpected cards present"; }
                     else if (tc.unexpectedCheck.passed && !tc.expectedCheck.passed) { failureReason = "Expected cards missing"; }
                     else if (!tc.unexpectedCheck.passed && !tc.expectedCheck.passed) { failureReason = "Both expected missing and unexpected present"; }
                     else { failureReason = "Unknown failure state"; }
                     return { testCaseId: tc.id, failureReason };
                 });

             return {
                 summary: { totalTests: uniqueTestCases.length, passedTests, failedTests, expectedFailedTests, unexpectedFailedTests, cardSeries: [...allCardSeries] },
                 testCases: uniqueTestCases,
                 failures: failureAnalysis
             };
        };


        // --- Rendering Functions ---

        function renderSummaryCharts() {
            if (!testData || !testData.summary) {
                summaryChartsContainer.innerHTML = ''; return;
            }

            // Destroy previous charts if they exist
            if (pieChartInstance) pieChartInstance.destroy();
            if (barChartInstance) barChartInstance.destroy();

            summaryChartsContainer.innerHTML = `
                 <div id="pieChartContainerWrapper" class="bg-white p-4 rounded-lg shadow-md w-full md:w-1/2"></div>
                 <div id="barChartContainerWrapper" class="bg-white p-4 rounded-lg shadow-md w-full md:w-1/2"></div>
            `; // Reset containers

            const { totalTests, passedTests, expectedFailedTests, unexpectedFailedTests } = testData.summary;
            const pieChartContainerWrapper = document.getElementById('pieChartContainerWrapper');
            const barChartContainerWrapper = document.getElementById('barChartContainerWrapper');


            // --- Pie Chart ---
            pieChartContainerWrapper.innerHTML = `
                <h3 class="text-xl font-bold mb-4">Test Results Summary</h3>
                <div class="chart-container mb-4"><canvas id="pieChartCanvas"></canvas></div>
                <div class="flex flex-wrap justify-around mt-4 summary-stats">
                    <div class="text-center mx-2 mb-2"><p class="label">Total Tests</p><p class="value">${totalTests}</p></div>
                    <div class="text-center mx-2 mb-2"><p class="label text-green-600">Passed</p><p class="value text-green-600">${passedTests}</p></div>
                    <div class="text-center mx-2 mb-2"><p class="label text-amber-500">Expected Fails</p><p class="value text-amber-500">${expectedFailedTests}</p></div>
                    <div class="text-center mx-2 mb-2"><p class="label text-red-500">Unexpected Fails</p><p class="value text-red-500">${unexpectedFailedTests}</p></div>
                </div>`;
             const pieCtx = document.getElementById('pieChartCanvas').getContext('2d');
             pieChartInstance = new Chart(pieCtx, { /* ... Pie Chart config ... */
                 type: 'pie', data: { labels: ['Passed', 'Expected Failures', 'Unexpected Failures'], datasets: [{ label: 'Test Results', data: [passedTests, expectedFailedTests, unexpectedFailedTests], backgroundColor: [COLORS.passed, COLORS.expectedFail, COLORS.failed], hoverOffset: 4 }] }, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'top' }, tooltip: { callbacks: { label: (c) => `${c.label || ''}: ${c.parsed || 0} tests` } } } }
             });


            // --- Bar Chart ---
            const seriesCounts = {};
            testData.testCases.forEach(tc => tc.cardSeries.forEach(series => { seriesCounts[series] = (seriesCounts[series] || 0) + 1; }));
            const seriesLabels = Object.keys(seriesCounts);
            const seriesDataValues = seriesLabels.map(series => seriesCounts[series]);
            const seriesColors = seriesLabels.map(series => COLORS[series] || COLORS.default);

            barChartContainerWrapper.innerHTML = `
                 <h3 class="text-xl font-bold mb-4">Card Series Distribution</h3>
                 <div class="chart-container"><canvas id="barChartCanvas"></canvas></div>`;
            const barCtx = document.getElementById('barChartCanvas').getContext('2d');
             barChartInstance = new Chart(barCtx, { /* ... Bar Chart config ... */
                 type: 'bar', data: { labels: seriesLabels, datasets: [{ label: 'Test Cases', data: seriesDataValues, backgroundColor: seriesColors, borderWidth: 1 }] }, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false }, tooltip: { callbacks: { label: (c) => ` ${c.parsed.y} tests` } } }, scales: { y: { beginAtZero: true, ticks: { stepSize: 1 } } } }
             });
            summaryChartsContainer.style.display = 'flex';
        }

        function generateCardListHTML(cards, title, borderColorClass) {
            if (!cards || cards.length === 0) return '';

            // Check toggle states
            const showName = document.getElementById('toggleName').checked;
            const showSetName = document.getElementById('toggleSetName').checked;
            const showSetNumber = document.getElementById('toggleSetNumber').checked;
            const showSetAbbr = document.getElementById('toggleSetAbbr').checked;
            const showPrice = document.getElementById('togglePrice').checked;
            const showHash = document.getElementById('toggleHash').checked;

            const listItems = cards.map((card, idx) => {
                let cardDetails = `<span class="card-detail card-id">${card.id || '&lt;no id&gt;'}</span>`; // ID always shown

                if (showName && card.name) cardDetails += `: <span class="card-detail card-name">${card.name}</span>`;
                if (showSetName && card.setName) cardDetails += `<span class="card-detail card-set-name"> (${card.setName})</span>`;
                if (showSetNumber && card.setNumber) cardDetails += `<span class="card-detail card-set-number"> #${card.setNumber}</span>`;
                if (showSetAbbr && card.setAbbreviation) cardDetails += `<span class="card-detail card-set-abbr"> [${card.setAbbreviation}]</span>`;
                if (showPrice && card.price) cardDetails += `<span class="card-detail card-price"> ${card.price}</span>`;
                if (showHash && card.playTextHash) cardDetails += `<span class="card-detail card-hash">Hash: ${card.playTextHash}</span>`; // Hash on new line for clarity

                return `<li key="${idx}">${cardDetails}</li>`;
            }).join('');

            return `
                <div class="card-list ${borderColorClass}">
                    <h4>${title} (${cards.length})</h4>
                    <ul>${listItems}</ul>
                </div>
            `;
        }

        function renderTestCases() {
            if (!testData || !testData.testCases) {
                testCasesContainer.innerHTML = '<h3 class="text-xl font-bold mb-4">Test Cases</h3><p>No test cases found or parsed.</p>';
                return;
            }

            let testCasesHTML = '<h3 class="text-xl font-bold mb-4">Test Cases</h3>';
            testData.testCases.forEach((testCase) => {
                 const isExpanded = expandedTestCase === testCase.id;
                 const statusIcon = testCase.passed ? ICONS.Check : (testCase.supposedToFail ? ICONS.XFailExpected : ICONS.XFailUnexpected);
                 const expandIcon = isExpanded ? ICONS.ChevronUp : ICONS.ChevronDown;
                 const seriesIndicators = testCase.cardSeries.map(series => `<span class="ml-1 inline-block w-4 h-4 rounded-full" style="background-color: ${COLORS[series] || COLORS.default};" title="Series: ${series}"></span>`).join('');
                 const expectedFailBadge = (!testCase.passed && testCase.supposedToFail) ? `<span class="badge bg-amber-100 text-amber-800">Expected to Fail</span>` : '';
                 const categoryBadge = testCase.categories.length > 0 ? `<span class="badge bg-gray-100 text-gray-600">${testCase.categories.join(', ')}</span>` : '';

                 const failureReason = (!testCase.passed && isExpanded) ? `<div class="col-span-1 md:col-span-2 failure-reason"><p><strong>Failure Reason:</strong> ${testData.failures.find(f => f.testCaseId === testCase.id)?.failureReason || 'Unknown'}</p></div>` : '';

                 const detailsHTML = isExpanded ? `
                     <div class="mt-2 ml-6 grid grid-cols-1 md:grid-cols-2 gap-x-4 gap-y-1">
                         ${generateCardListHTML(testCase.expectedCards, 'Expected Cards', 'border-blue-400')}
                         ${generateCardListHTML(testCase.unexpectedCards, 'Unexpected Cards', 'border-orange-400')}
                         ${failureReason}
                     </div>
                 ` : '';

                 testCasesHTML += `
                     <div class="border-b border-gray-200 py-2 last:border-b-0">
                         <div class="flex items-center justify-between test-case-header" data-id="${testCase.id}">
                             <div class="flex items-center flex-wrap"> ${statusIcon} <span class="font-medium mr-2">Test Case #${testCase.id}</span> ${expectedFailBadge} ${categoryBadge} </div>
                             <div class="flex items-center flex-shrink-0 pl-2"> <div class="flex mr-2">${seriesIndicators}</div> ${expandIcon} </div>
                         </div>
                         <div class="test-case-details">${detailsHTML}</div>
                     </div>`;
            });
            testCasesContainer.innerHTML = testCasesHTML;
            testCasesContainer.style.display = 'block';
        }


        // --- Event Handlers ---
        function handleParse() {
            const text = logInput.value;
            errorMessage.textContent = '';
            testData = null;
            expandedTestCase = null;
            summaryChartsContainer.style.display = 'none';
            testCasesContainer.style.display = 'none';

            if (!text.trim()) {
                errorMessage.textContent = "Please paste the log data first"; return;
            }
            try {
                testData = parseTestResults(text);
                renderSummaryCharts();
                renderTestCases();
            } catch (err) {
                errorMessage.textContent = `Error parsing data: ${err.message}`;
                console.error("Parsing Error:", err);
                summaryChartsContainer.innerHTML = ''; // Clear results on error
                testCasesContainer.innerHTML = '';
            }
        }

        function handleExpandToggle(event) {
            const header = event.target.closest('.test-case-header');
            if (!header) return;
            const id = parseInt(header.getAttribute('data-id'), 10);
            if (isNaN(id)) return;
            expandedTestCase = (expandedTestCase === id) ? null : id;
            renderTestCases(); // Only need to re-render test cases on expand/collapse
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            parseButton.addEventListener('click', handleParse);
            testCasesContainer.addEventListener('click', handleExpandToggle);

            // Add listeners to toggles to re-render test cases on change
            const toggles = displayOptionsContainer.querySelectorAll('input[type="checkbox"]');
            toggles.forEach(toggle => {
                toggle.addEventListener('change', () => {
                    if (testData) { // Only re-render if data has been parsed
                        renderTestCases();
                    }
                });
            });

            // Hide results initially
            summaryChartsContainer.style.display = 'none';
            testCasesContainer.style.display = 'none';
        });

    </script>

</body>
</html>
